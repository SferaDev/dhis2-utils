Index: src/main/java/org/hisp/dhis/datageneration/generator/TeiGenerator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.hisp.dhis.datageneration.generator;\n\n/*\n * Copyright (c) 2004-2019, University of Oslo\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n * Neither the name of the HISP project nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport static net.andreinc.mockneat.unit.text.SQLInserts.sqlInserts;\nimport static net.andreinc.mockneat.unit.time.LocalDates.localDates;\nimport static net.andreinc.mockneat.unit.types.Bools.bools;\nimport static net.andreinc.mockneat.unit.types.Doubles.doubles;\nimport static net.andreinc.mockneat.unit.types.Ints.ints;\nimport static org.hisp.dhis.datageneration.utils.PostgreSQL.TEXT_BACKSLASH;\nimport static org.hisp.dhis.datageneration.utils.PostgreSQL.TEXT_BACKSLASH_NO_ESCAPE;\nimport static org.hisp.dhis.datageneration.utils.RandomUtils.*;\n\nimport java.io.File;\nimport java.time.format.DateTimeFormatter;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nimport org.hisp.dhis.common.CodeGenerator;\nimport org.hisp.dhis.common.ValueType;\nimport org.hisp.dhis.datageneration.cache.*;\nimport org.hisp.dhis.datageneration.domain.*;\nimport org.hisp.dhis.datageneration.id.IdFactory;\nimport org.hisp.dhis.datageneration.observer.ProgressUpdateEvent;\nimport org.hisp.dhis.datageneration.utils.CollectionSizer;\nimport org.hisp.dhis.datageneration.writer.SqlStatementsWriter;\nimport org.hisp.dhis.dxf2.events.event.DataValue;\nimport org.springframework.stereotype.Component;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.base.Joiner;\nimport com.vividsolutions.jts.geom.Point;\n\nimport lombok.extern.java.Log;\nimport net.andreinc.mockneat.types.enums.StringType;\nimport net.andreinc.mockneat.unit.objects.From;\nimport net.andreinc.mockneat.unit.text.Strings;\nimport net.andreinc.mockneat.unit.text.sql.SQLInsert;\n\n/**\n * @author Luciano Fiandesio\n */\n@Log\n@Component\npublic class TeiGenerator\n    extends\n    Observable\n    implements\n    Generator\n{\n\n    private final IdFactory idFactory;\n\n    private final EntityCache entityCache;\n\n    private final SqlStatementsWriter writer;\n\n    private final Observer observer;\n\n    private ObjectMapper mapper;\n\n    private final int CHUNCK_SIZE = 5000;\n\n    public TeiGenerator(EntityCache entityCache, IdFactory idFactory, SqlStatementsWriter writer, Observer observer)\n    {\n        this.entityCache = entityCache;\n        this.idFactory = idFactory;\n        this.writer = writer;\n        this.observer = observer;\n\n        mapper =  new ObjectMapper();\n    }\n\n    public void generate( DefaultGenerationOptions options, EntityCache entityCache )\n    {\n        long teiIdStart = idFactory.getStartTeiId();\n        long piIdStart = idFactory.getStartProgramInstanceId();\n        long psiIdStart = idFactory.getStartProgramStageInstanceId();\n\n        // TODO does it make sense to randomize this?\n        long defaultaoc = entityCache.getCategoryOptionCombos().stream().filter( CategoryOptionCombo::isDefaultCoc )\n            .findFirst().get().getId();\n\n        long totalChuncks = (options.getQuantity() < CHUNCK_SIZE ? 1 : options.getQuantity() / CHUNCK_SIZE);\n        int currentChunkSize = 0;\n        long processedChuncks = 0;\n\n        List<String> statements = new ArrayList<>();\n        for ( int i = 0; i < options.getQuantity(); i++ )\n        {\n            // Get a program that is type Tracker\n            Program program = getRandomTrackerProgram( entityCache );\n\n            long teiId = teiIdStart + i;\n            long piId = piIdStart + i;\n            // pick a random OU from the program\n            long ouId = From.from(program.getOrgUnits()).get().getId();\n\n\n            statements.add(sqlInserts().tableName( \"trackedentityinstance\" )\n                .column( \"trackedentityinstanceid\", Long.toString( teiId ) )\n                .column( \"organisationunitid\", Long.toString( ouId ) )\n                .column( \"uid\", CodeGenerator.generateUid(), TEXT_BACKSLASH )\n                .column( \"created\", localDateTime(), TEXT_BACKSLASH )\n                .column( \"lastupdated\", localDateTime(), TEXT_BACKSLASH )\n                .column( \"trackedentitytypeid\", program.getTeiType().toString() )\n                .column( \"inactive\", \"false\", TEXT_BACKSLASH )\n                // .column(\"lastupdatedby\", localDates().thisYear().display(BASIC_ISO_DATE))\n                .column( \"createdatclient\", localDateTime(), TEXT_BACKSLASH )\n                // .column(\"lastupdatedatclient\",\n                .column( \"deleted\", \"false\", TEXT_BACKSLASH )\n                // .column(\"geometry\", localDates().thisYear().display(BASIC_ISO_DATE))\n                .column( \"featuretype\", \"NONE\", TEXT_BACKSLASH )\n                // .column(\"coordinates\", localDates().thisYear().display(BASIC_ISO_DATE))\n                // .column(\"code\", strings().size(5), TEXT_BACKSLASH)\n                // .column(\"created\", \"2014-03-26 15:40:12\", TEXT_BACKSLASH)\n                .get().toString());\n\n            String created = localDateTime();\n            String enrollmentDate = localDateTime();\n\n            statements.add( sqlInserts().tableName( \"programinstance\" )\n                .column( \"programinstanceid\", Long.toString( piId ) )\n                .column( \"enrollmentdate\", enrollmentDate, TEXT_BACKSLASH )\n                .column( \"programid\", program.getId().toString() )\n                .column( \"status\", \"COMPLETED\", TEXT_BACKSLASH )\n                .column( \"uid\", CodeGenerator.generateUid(), TEXT_BACKSLASH )\n                .column( \"created\", created, TEXT_BACKSLASH )\n                .column( \"lastUpdated\", created, TEXT_BACKSLASH )\n                .column( \"trackedentityinstanceid\", Long.toString( teiId ) )\n                .column( \"organisationunitid\", Long.toString( ouId ) )\n                .column( \"incidentdate\", enrollmentDate, TEXT_BACKSLASH )\n                .column( \"createdatclient\", localDateTime(), TEXT_BACKSLASH )\n                .column( \"deleted\", \"false\", TEXT_BACKSLASH )\n                .get().toString());\n\n            int eventsSize = CollectionSizer.getCollectionSize( options.getTeiGenerationOptions().getEventsRange() );\n\n            ProgramStage programStage = From.from( program.getStages() ).get();\n\n            statements.add( Joiner.on( \"\\n\" ).join( IntStream.rangeClosed( 1, eventsSize ).mapToObj(ev -> {\n                long psiId = psiIdStart + 1;\n                return sqlInserts().tableName( \"programstageinstance\" )\n                    .column( \"programstageinstanceid\", Long.toString( psiId ) )\n                    .column( \"programinstanceid\", Long.toString( piId ) )\n                    .column( \"programstageid\", Long.toString( programStage.getId() ) )\n                    .column( \"duedate\", localDateTimeInFuture(), TEXT_BACKSLASH )\n                    // .column( \"executiondate\", rndFactory.dateTimesInFuture(), TEXT_BACKSLASH )\n                    // TODO ok to be null ?\n                    // .column( \"completed\", rndFactory.dateTimesInFuture(), TEXT_BACKSLASH ) TODO\n                    // ok to be null ?\n                    .column( \"organisationunitid\", Long.toString( ouId ) )\n                    .column( \"status\", \"ACTIVE\", TEXT_BACKSLASH )\n                    .column( \"uid\", CodeGenerator.generateUid(), TEXT_BACKSLASH )\n                    .column( \"created\", created, TEXT_BACKSLASH )\n                    .column( \"lastupdated\", created, TEXT_BACKSLASH )\n                    .column( \"attributeoptioncomboid\", Long.toString( defaultaoc ) )\n                    .column( \"deleted\", \"false\", TEXT_BACKSLASH )\n                    .column( \"eventdatavalues\", createDataValuesAsJson(programStage, options.getTeiGenerationOptions().getDataValueRange() ), TEXT_BACKSLASH_NO_ESCAPE  )\n                    .get().toString();\n            } ).collect( Collectors.toList() ) ) );\n\n            // how many program attributes to create //\n            int attributeSize = CollectionSizer.getCollectionSize(options.getTeiGenerationOptions().getEventsRange(), program.getAttributes().size());\n\n            statements.add( Joiner.on( \"\\n\" )\n                .join( IntStream.rangeClosed( 1, attributeSize )\n                    .mapToObj( ev -> {\n\n                        ProgramAttribute attribute = From.from( program.getAttributes() ).get();\n\n                        return sqlInserts().tableName( \"trackedentityattributevalue\" )\n                                .column( \"trackedentityinstanceid\", Long.toString( teiId ) )\n                                .column( \"trackedentityattributeid\", Long.toString( attribute.getId() ) )\n                                .column( \"value\", rndValueFrom( attribute.getValueType() ), TEXT_BACKSLASH )\n                                .column( \"created\", created, TEXT_BACKSLASH )\n                                .column( \"lastupdated\", created, TEXT_BACKSLASH ).get().toString();\n                    } )\n                    .collect( Collectors.toList() ) ) );\n\n            currentChunkSize++;\n            if ( currentChunkSize == CHUNCK_SIZE)\n            {\n                // flush to file the current chunk\n                writer.write( new File( options.getFile() ), statements );\n                // Reset StringBuilder\n                statements = new ArrayList<>();\n                // reset chunk count\n                currentChunkSize = 0;\n                // increment number of processed chunks so far\n                processedChuncks ++;\n                // send event for progress bar in CLI\n                fireProgressEvent( processedChuncks, totalChuncks);\n            }\n        }\n        // flush remaining data\n        writer.write( new File( options.getFile() ), statements );\n    }\n    \n    private void fireProgressEvent( long processedChuncks, long totalChuncks )\n    {\n        if ( observer != null )\n        {\n            String message = \"\";\n            if ( processedChuncks < totalChuncks )\n            {\n                message = \":: please WAIT ::\";\n            }\n            observer.update( this, new ProgressUpdateEvent( processedChuncks, totalChuncks, message ) );\n        }\n\n    }\n    \n    private Program getRandomTrackerProgram( EntityCache entityCache )\n    {\n        return From.from(\n            entityCache.getPrograms().stream().filter( p -> p.getTeiType() != 0 ).collect( Collectors.toList() ) )\n            .get();\n    }\n\n    private String createDataValuesAsJson( ProgramStage programStage, String dataValueSizeRange )\n    {\n        int dataElementsSize = CollectionSizer.getCollectionSize( dataValueSizeRange,\n            programStage.getDataElements().size() );\n\n        // Generate a sequence of int from 0 to max data elements for given program stage\n        List<Integer> indexes = IntStream.range(0, programStage.getDataElements().size() -1).boxed()\n                .collect(Collectors.toCollection(ArrayList::new));\n        // randomize!\n        Collections.shuffle(indexes);\n        // pick only the first x numbers based on randomized user selection\n        indexes = indexes.subList(0, dataElementsSize);\n        List<String> values = new ArrayList<>();\n\n        for (Integer index : indexes)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            DataElement de = programStage.getDataElements().get( index );\n\n            DataValue dv = withRandomValue( de );\n            sb.append( \"\\\"\" ).append( de.getUid() ).append( \"\\\":\" );\n            try\n            {\n                sb.append( mapper.writeValueAsString( dv ) );\n            }\n            catch ( Exception e )\n            {\n                e.printStackTrace(); // TODO\n            }\n            values.add(sb.toString());\n        }\n        return \"{\" + Joiner.on(\",\").join(values) + \"}\";\n\n    }\n\n    private DataValue withRandomValue( DataElement dataElement)\n    {\n        DataValue dataValue = new DataValue();\n        dataValue.setDataElement( dataElement.getUid() );\n        dataValue.setProvidedElsewhere( false );\n        String val;\n\n        if ( dataElement.getOptionSet() != null && !dataElement.getOptionSet().isEmpty() )\n        {\n            val = dataElement.getOptionSet().get( ints().range( 0, dataElement.getOptionSet().size() - 1 ).get() );\n        }\n        else\n        {\n            val = rndValueFrom( dataElement.getValueType() );\n        }\n        dataValue.setValue( val );\n        return dataValue;\n    }\n    \n    private String rndValueFrom(ValueType valueType) {\n        String val = null;\n        \n        if ( valueType.isBoolean() )\n        {\n            if ( valueType.equals( ValueType.BOOLEAN ) )\n            {\n                val = String.valueOf( bools().get() );\n            }\n            else\n            {\n                // TRUE_ONLY\n                val = \"true\";\n            }\n        }\n\n        else if ( valueType.isDate() )\n        {\n            val = localDates().display( DateTimeFormatter.ISO_LOCAL_DATE ).get();\n        }\n\n        else if ( valueType.isNumeric() )\n        {\n            val = String.valueOf( ints().range( 1, 10000 ).get());\n        }\n        else if ( valueType.isDecimal() )\n        {\n            val = String.valueOf( doubles().range( 100.0, 1000.0 ).get() );\n        }\n        else if ( valueType.isText() )\n        {\n            val = Strings.strings().type(StringType.LETTERS).get();\n        }\n        else if ( valueType.isOrganisationUnit() )\n        {\n            val = \"\"; // TODO\n        }\n        else if ( valueType.isGeo() )\n        {\n            Point p = createRandomPoint();\n            val = p.getY() + \", \" + p.getY();\n        }\n        return val;\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/org/hisp/dhis/datageneration/generator/TeiGenerator.java	(date 1568652532000)
+++ src/main/java/org/hisp/dhis/datageneration/generator/TeiGenerator.java	(date 1568653991356)
@@ -45,7 +45,7 @@
 
 import org.hisp.dhis.common.CodeGenerator;
 import org.hisp.dhis.common.ValueType;
-import org.hisp.dhis.datageneration.cache.*;
+import org.hisp.dhis.datageneration.cache.EntityCache;
 import org.hisp.dhis.datageneration.domain.*;
 import org.hisp.dhis.datageneration.id.IdFactory;
 import org.hisp.dhis.datageneration.observer.ProgressUpdateEvent;
@@ -62,7 +62,6 @@
 import net.andreinc.mockneat.types.enums.StringType;
 import net.andreinc.mockneat.unit.objects.From;
 import net.andreinc.mockneat.unit.text.Strings;
-import net.andreinc.mockneat.unit.text.sql.SQLInsert;
 
 /**
  * @author Luciano Fiandesio
@@ -100,6 +99,7 @@
 
     public void generate( DefaultGenerationOptions options, EntityCache entityCache )
     {
+        // fetch the first available IDS from target tables
         long teiIdStart = idFactory.getStartTeiId();
         long piIdStart = idFactory.getStartProgramInstanceId();
         long psiIdStart = idFactory.getStartProgramStageInstanceId();
@@ -115,97 +115,10 @@
         List<String> statements = new ArrayList<>();
         for ( int i = 0; i < options.getQuantity(); i++ )
         {
-            // Get a program that is type Tracker
-            Program program = getRandomTrackerProgram( entityCache );
-
-            long teiId = teiIdStart + i;
-            long piId = piIdStart + i;
-            // pick a random OU from the program
-            long ouId = From.from(program.getOrgUnits()).get().getId();
-
-
-            statements.add(sqlInserts().tableName( "trackedentityinstance" )
-                .column( "trackedentityinstanceid", Long.toString( teiId ) )
-                .column( "organisationunitid", Long.toString( ouId ) )
-                .column( "uid", CodeGenerator.generateUid(), TEXT_BACKSLASH )
-                .column( "created", localDateTime(), TEXT_BACKSLASH )
-                .column( "lastupdated", localDateTime(), TEXT_BACKSLASH )
-                .column( "trackedentitytypeid", program.getTeiType().toString() )
-                .column( "inactive", "false", TEXT_BACKSLASH )
-                // .column("lastupdatedby", localDates().thisYear().display(BASIC_ISO_DATE))
-                .column( "createdatclient", localDateTime(), TEXT_BACKSLASH )
-                // .column("lastupdatedatclient",
-                .column( "deleted", "false", TEXT_BACKSLASH )
-                // .column("geometry", localDates().thisYear().display(BASIC_ISO_DATE))
-                .column( "featuretype", "NONE", TEXT_BACKSLASH )
-                // .column("coordinates", localDates().thisYear().display(BASIC_ISO_DATE))
-                // .column("code", strings().size(5), TEXT_BACKSLASH)
-                // .column("created", "2014-03-26 15:40:12", TEXT_BACKSLASH)
-                .get().toString());
-
-            String created = localDateTime();
-            String enrollmentDate = localDateTime();
 
-            statements.add( sqlInserts().tableName( "programinstance" )
-                .column( "programinstanceid", Long.toString( piId ) )
-                .column( "enrollmentdate", enrollmentDate, TEXT_BACKSLASH )
-                .column( "programid", program.getId().toString() )
-                .column( "status", "COMPLETED", TEXT_BACKSLASH )
-                .column( "uid", CodeGenerator.generateUid(), TEXT_BACKSLASH )
-                .column( "created", created, TEXT_BACKSLASH )
-                .column( "lastUpdated", created, TEXT_BACKSLASH )
-                .column( "trackedentityinstanceid", Long.toString( teiId ) )
-                .column( "organisationunitid", Long.toString( ouId ) )
-                .column( "incidentdate", enrollmentDate, TEXT_BACKSLASH )
-                .column( "createdatclient", localDateTime(), TEXT_BACKSLASH )
-                .column( "deleted", "false", TEXT_BACKSLASH )
-                .get().toString());
-
-            int eventsSize = CollectionSizer.getCollectionSize( options.getTeiGenerationOptions().getEventsRange() );
-
-            ProgramStage programStage = From.from( program.getStages() ).get();
-
-            statements.add( Joiner.on( "\n" ).join( IntStream.rangeClosed( 1, eventsSize ).mapToObj(ev -> {
-                long psiId = psiIdStart + 1;
-                return sqlInserts().tableName( "programstageinstance" )
-                    .column( "programstageinstanceid", Long.toString( psiId ) )
-                    .column( "programinstanceid", Long.toString( piId ) )
-                    .column( "programstageid", Long.toString( programStage.getId() ) )
-                    .column( "duedate", localDateTimeInFuture(), TEXT_BACKSLASH )
-                    // .column( "executiondate", rndFactory.dateTimesInFuture(), TEXT_BACKSLASH )
-                    // TODO ok to be null ?
-                    // .column( "completed", rndFactory.dateTimesInFuture(), TEXT_BACKSLASH ) TODO
-                    // ok to be null ?
-                    .column( "organisationunitid", Long.toString( ouId ) )
-                    .column( "status", "ACTIVE", TEXT_BACKSLASH )
-                    .column( "uid", CodeGenerator.generateUid(), TEXT_BACKSLASH )
-                    .column( "created", created, TEXT_BACKSLASH )
-                    .column( "lastupdated", created, TEXT_BACKSLASH )
-                    .column( "attributeoptioncomboid", Long.toString( defaultaoc ) )
-                    .column( "deleted", "false", TEXT_BACKSLASH )
-                    .column( "eventdatavalues", createDataValuesAsJson(programStage, options.getTeiGenerationOptions().getDataValueRange() ), TEXT_BACKSLASH_NO_ESCAPE  )
-                    .get().toString();
-            } ).collect( Collectors.toList() ) ) );
-
-            // how many program attributes to create //
-            int attributeSize = CollectionSizer.getCollectionSize(options.getTeiGenerationOptions().getEventsRange(), program.getAttributes().size());
-
-            statements.add( Joiner.on( "\n" )
-                .join( IntStream.rangeClosed( 1, attributeSize )
-                    .mapToObj( ev -> {
-
-                        ProgramAttribute attribute = From.from( program.getAttributes() ).get();
-
-                        return sqlInserts().tableName( "trackedentityattributevalue" )
-                                .column( "trackedentityinstanceid", Long.toString( teiId ) )
-                                .column( "trackedentityattributeid", Long.toString( attribute.getId() ) )
-                                .column( "value", rndValueFrom( attribute.getValueType() ), TEXT_BACKSLASH )
-                                .column( "created", created, TEXT_BACKSLASH )
-                                .column( "lastupdated", created, TEXT_BACKSLASH ).get().toString();
-                    } )
-                    .collect( Collectors.toList() ) ) );
 
             currentChunkSize++;
+
             if ( currentChunkSize == CHUNCK_SIZE)
             {
                 // flush to file the current chunk
@@ -237,112 +150,5 @@
         }
 
     }
-    
-    private Program getRandomTrackerProgram( EntityCache entityCache )
-    {
-        return From.from(
-            entityCache.getPrograms().stream().filter( p -> p.getTeiType() != 0 ).collect( Collectors.toList() ) )
-            .get();
-    }
-
-    private String createDataValuesAsJson( ProgramStage programStage, String dataValueSizeRange )
-    {
-        int dataElementsSize = CollectionSizer.getCollectionSize( dataValueSizeRange,
-            programStage.getDataElements().size() );
-
-        // Generate a sequence of int from 0 to max data elements for given program stage
-        List<Integer> indexes = IntStream.range(0, programStage.getDataElements().size() -1).boxed()
-                .collect(Collectors.toCollection(ArrayList::new));
-        // randomize!
-        Collections.shuffle(indexes);
-        // pick only the first x numbers based on randomized user selection
-        indexes = indexes.subList(0, dataElementsSize);
-        List<String> values = new ArrayList<>();
-
-        for (Integer index : indexes)
-        {
-            StringBuilder sb = new StringBuilder();
-
-            DataElement de = programStage.getDataElements().get( index );
-
-            DataValue dv = withRandomValue( de );
-            sb.append( "\"" ).append( de.getUid() ).append( "\":" );
-            try
-            {
-                sb.append( mapper.writeValueAsString( dv ) );
-            }
-            catch ( Exception e )
-            {
-                e.printStackTrace(); // TODO
-            }
-            values.add(sb.toString());
-        }
-        return "{" + Joiner.on(",").join(values) + "}";
-
-    }
-
-    private DataValue withRandomValue( DataElement dataElement)
-    {
-        DataValue dataValue = new DataValue();
-        dataValue.setDataElement( dataElement.getUid() );
-        dataValue.setProvidedElsewhere( false );
-        String val;
-
-        if ( dataElement.getOptionSet() != null && !dataElement.getOptionSet().isEmpty() )
-        {
-            val = dataElement.getOptionSet().get( ints().range( 0, dataElement.getOptionSet().size() - 1 ).get() );
-        }
-        else
-        {
-            val = rndValueFrom( dataElement.getValueType() );
-        }
-        dataValue.setValue( val );
-        return dataValue;
-    }
-    
-    private String rndValueFrom(ValueType valueType) {
-        String val = null;
-        
-        if ( valueType.isBoolean() )
-        {
-            if ( valueType.equals( ValueType.BOOLEAN ) )
-            {
-                val = String.valueOf( bools().get() );
-            }
-            else
-            {
-                // TRUE_ONLY
-                val = "true";
-            }
-        }
-
-        else if ( valueType.isDate() )
-        {
-            val = localDates().display( DateTimeFormatter.ISO_LOCAL_DATE ).get();
-        }
-
-        else if ( valueType.isNumeric() )
-        {
-            val = String.valueOf( ints().range( 1, 10000 ).get());
-        }
-        else if ( valueType.isDecimal() )
-        {
-            val = String.valueOf( doubles().range( 100.0, 1000.0 ).get() );
-        }
-        else if ( valueType.isText() )
-        {
-            val = Strings.strings().type(StringType.LETTERS).get();
-        }
-        else if ( valueType.isOrganisationUnit() )
-        {
-            val = ""; // TODO
-        }
-        else if ( valueType.isGeo() )
-        {
-            Point p = createRandomPoint();
-            val = p.getY() + ", " + p.getY();
-        }
-        return val;
-    }
 
 }
Index: src/main/java/org/hisp/dhis/datageneration/command/DataGenerationCommand.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.hisp.dhis.datageneration.command;\n\n/*\n * Copyright (c) 2004-2019, University of Oslo\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n * Neither the name of the HISP project nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport java.time.Duration;\nimport java.time.Instant;\n\nimport org.hisp.dhis.datageneration.cache.EntityCache;\nimport org.hisp.dhis.datageneration.generator.DefaultGenerationOptions;\nimport org.hisp.dhis.datageneration.generator.GeneratorFactory;\nimport org.hisp.dhis.datageneration.generator.GeneratorType;\nimport org.hisp.dhis.datageneration.generator.TeiGenerationOptions;\nimport org.hisp.dhis.datageneration.shell.ProgressBar;\nimport org.hisp.dhis.datageneration.shell.ShellHelper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.shell.standard.ShellComponent;\nimport org.springframework.shell.standard.ShellMethod;\nimport org.springframework.shell.standard.ShellOption;\n\n/**\n * @author Luciano Fiandesio\n */\n@ShellComponent\npublic class DataGenerationCommand\n{\n\n    private final EntityCache entityCache;\n\n    private final GeneratorFactory factory;\n\n    private final ShellHelper shellHelper;\n\n    @Autowired\n    private ProgressBar progressBar;\n\n    public DataGenerationCommand( EntityCache entityCache, GeneratorFactory factory, ShellHelper shellHelper )\n    {\n        this.entityCache = entityCache;\n        this.factory = factory;\n        this.shellHelper = shellHelper;\n    }\n\n    @ShellMethod( \"Generate SQL Insert script\" )\n    public String gen(\n        @ShellOption( { \"-S\", \"--size\" } ) Long size,\n        @ShellOption( value = { \"-T\", \"--type\" }, help = \"available options: TEI\" ) String type,\n        @ShellOption( value = { \"-F\", \"--file\" }, help = \"full path to destination file (e.g. /home/kirk/myfile.sql)\" ) String pathToFile )\n    {\n        Instant startGen = Instant.now();\n\n        if ( !entityCache.isInit() )\n        {\n            Instant start = Instant.now();\n            entityCache.init();\n            Instant finish = Instant.now();\n            shellHelper\n                .printInfo( String.format( \"Cache created in %d ms.\", Duration.between( start, finish ).toMillis() ) );\n\n        }\n\n        this.factory.getGenerator( GeneratorType.valueOf( type ) ).generate( DefaultGenerationOptions.builder()\n            .file( pathToFile ).quantity( size ).teiGenerationOptions( TeiGenerationOptions.builder()\n                .eventsRange( \"1-10\" ).attributeRange( \"1-10\" ).dataValueRange( \"1-10\" ).build() )\n            .build(), entityCache );\n\n        return String.format( \"Generation completed in %d ms.\",\n            Duration.between( startGen, Instant.now() ).toMillis() );\n\n    }\n\n    @ShellMethod(\"Displays progress bar\")\n    public void progressBar() throws InterruptedException {\n        for (int i = 1; i <=100; i++) {\n            progressBar.display(i);\n            Thread.sleep(100);\n        }\n        progressBar.reset();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/org/hisp/dhis/datageneration/command/DataGenerationCommand.java	(date 1568652532000)
+++ src/main/java/org/hisp/dhis/datageneration/command/DataGenerationCommand.java	(date 1568653807173)
@@ -38,7 +38,6 @@
 import org.hisp.dhis.datageneration.generator.TeiGenerationOptions;
 import org.hisp.dhis.datageneration.shell.ProgressBar;
 import org.hisp.dhis.datageneration.shell.ShellHelper;
-import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.shell.standard.ShellComponent;
 import org.springframework.shell.standard.ShellMethod;
 import org.springframework.shell.standard.ShellOption;
@@ -56,14 +55,14 @@
 
     private final ShellHelper shellHelper;
 
-    @Autowired
     private ProgressBar progressBar;
 
-    public DataGenerationCommand( EntityCache entityCache, GeneratorFactory factory, ShellHelper shellHelper )
+    public DataGenerationCommand( EntityCache entityCache, GeneratorFactory factory, ShellHelper shellHelper, ProgressBar progressBar )
     {
         this.entityCache = entityCache;
         this.factory = factory;
         this.shellHelper = shellHelper;
+        this.progressBar = progressBar;
     }
 
     @ShellMethod( "Generate SQL Insert script" )
@@ -86,20 +85,14 @@
 
         this.factory.getGenerator( GeneratorType.valueOf( type ) ).generate( DefaultGenerationOptions.builder()
             .file( pathToFile ).quantity( size ).teiGenerationOptions( TeiGenerationOptions.builder()
-                .eventsRange( "1-10" ).attributeRange( "1-10" ).dataValueRange( "1-10" ).build() )
+                .eventsRange( "1-10" )
+                .attributeRange( "1-10" )
+                .dataValueRange( "1-10" ).build() )
+
             .build(), entityCache );
 
         return String.format( "Generation completed in %d ms.",
             Duration.between( startGen, Instant.now() ).toMillis() );
 
-    }
-
-    @ShellMethod("Displays progress bar")
-    public void progressBar() throws InterruptedException {
-        for (int i = 1; i <=100; i++) {
-            progressBar.display(i);
-            Thread.sleep(100);
-        }
-        progressBar.reset();
     }
 }
Index: src/main/java/org/hisp/dhis/datageneration/generator/unit/TeiUnit.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/org/hisp/dhis/datageneration/generator/unit/TeiUnit.java	(date 1568653944224)
+++ src/main/java/org/hisp/dhis/datageneration/generator/unit/TeiUnit.java	(date 1568653944224)
@@ -0,0 +1,271 @@
+package org.hisp.dhis.datageneration.generator.unit;
+
+/*
+ * Copyright (c) 2004-2019, University of Oslo
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ * Neither the name of the HISP project nor the names of its contributors may
+ * be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+import com.google.common.base.Joiner;
+import com.vividsolutions.jts.geom.Point;
+import net.andreinc.mockneat.types.enums.StringType;
+import net.andreinc.mockneat.unit.objects.From;
+import net.andreinc.mockneat.unit.text.Strings;
+import org.hisp.dhis.common.CodeGenerator;
+import org.hisp.dhis.common.ValueType;
+import org.hisp.dhis.datageneration.cache.EntityCache;
+import org.hisp.dhis.datageneration.domain.DataElement;
+import org.hisp.dhis.datageneration.domain.Program;
+import org.hisp.dhis.datageneration.domain.ProgramAttribute;
+import org.hisp.dhis.datageneration.domain.ProgramStage;
+import org.hisp.dhis.datageneration.generator.DefaultGenerationOptions;
+import org.hisp.dhis.datageneration.utils.CollectionSizer;
+import org.hisp.dhis.dxf2.events.event.DataValue;
+
+import java.time.format.DateTimeFormatter;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+
+import static net.andreinc.mockneat.unit.text.SQLInserts.sqlInserts;
+import static net.andreinc.mockneat.unit.time.LocalDates.localDates;
+import static net.andreinc.mockneat.unit.types.Bools.bools;
+import static net.andreinc.mockneat.unit.types.Doubles.doubles;
+import static net.andreinc.mockneat.unit.types.Ints.ints;
+import static org.hisp.dhis.datageneration.utils.PostgreSQL.TEXT_BACKSLASH;
+import static org.hisp.dhis.datageneration.utils.PostgreSQL.TEXT_BACKSLASH_NO_ESCAPE;
+import static org.hisp.dhis.datageneration.utils.RandomUtils.*;
+
+/**
+ * @author Luciano Fiandesio
+ */
+public class TeiUnit {
+
+    public List<String> get(DefaultGenerationOptions options, EntityCache entityCache ) {
+
+        List<String> statements = new ArrayList<>();
+
+        // Get a program that is type Tracker
+        Program program = getRandomTrackerProgram( entityCache );
+
+        long teiId = teiIdStart + i;
+        long piId = piIdStart + i;
+        // pick a random OU from the program
+        long ouId = From.from(program.getOrgUnits()).get().getId();
+
+
+        statements.add( sqlInserts().tableName( "trackedentityinstance" )
+                .column( "trackedentityinstanceid", Long.toString( teiId ) )
+                .column( "organisationunitid", Long.toString( ouId ) )
+                .column( "uid", CodeGenerator.generateUid(), TEXT_BACKSLASH )
+                .column( "created", localDateTime(), TEXT_BACKSLASH )
+                .column( "lastupdated", localDateTime(), TEXT_BACKSLASH )
+                .column( "trackedentitytypeid", program.getTeiType().toString() )
+                .column( "inactive", "false", TEXT_BACKSLASH )
+                // .column("lastupdatedby", localDates().thisYear().display(BASIC_ISO_DATE))
+                .column( "createdatclient", localDateTime(), TEXT_BACKSLASH )
+                // .column("lastupdatedatclient",
+                .column( "deleted", "false", TEXT_BACKSLASH )
+                // .column("geometry", localDates().thisYear().display(BASIC_ISO_DATE))
+                .column( "featuretype", "NONE", TEXT_BACKSLASH )
+                // .column("coordinates", localDates().thisYear().display(BASIC_ISO_DATE))
+                // .column("code", strings().size(5), TEXT_BACKSLASH)
+                // .column("created", "2014-03-26 15:40:12", TEXT_BACKSLASH)
+                .get().toString());
+
+        String created = localDateTime();
+        String enrollmentDate = localDateTime();
+
+        statements.add( sqlInserts().tableName( "programinstance" )
+                .column( "programinstanceid", Long.toString( piId ) )
+                .column( "enrollmentdate", enrollmentDate, TEXT_BACKSLASH )
+                .column( "programid", program.getId().toString() )
+                .column( "status", "COMPLETED", TEXT_BACKSLASH )
+                .column( "uid", CodeGenerator.generateUid(), TEXT_BACKSLASH )
+                .column( "created", created, TEXT_BACKSLASH )
+                .column( "lastUpdated", created, TEXT_BACKSLASH )
+                .column( "trackedentityinstanceid", Long.toString( teiId ) )
+                .column( "organisationunitid", Long.toString( ouId ) )
+                .column( "incidentdate", enrollmentDate, TEXT_BACKSLASH )
+                .column( "createdatclient", localDateTime(), TEXT_BACKSLASH )
+                .column( "deleted", "false", TEXT_BACKSLASH )
+                .get().toString());
+
+        int eventsSize = CollectionSizer.getCollectionSize( options.getTeiGenerationOptions().getEventsRange() );
+
+        ProgramStage programStage = From.from( program.getStages() ).get();
+
+        statements.add( Joiner.on( "\n" ).join( IntStream.rangeClosed( 1, eventsSize ).mapToObj(ev -> {
+            long psiId = psiIdStart + 1;
+            return sqlInserts().tableName( "programstageinstance" )
+                    .column( "programstageinstanceid", Long.toString( psiId ) )
+                    .column( "programinstanceid", Long.toString( piId ) )
+                    .column( "programstageid", Long.toString( programStage.getId() ) )
+                    .column( "duedate", localDateTimeInFuture(), TEXT_BACKSLASH )
+                    // .column( "executiondate", rndFactory.dateTimesInFuture(), TEXT_BACKSLASH )
+                    // TODO ok to be null ?
+                    // .column( "completed", rndFactory.dateTimesInFuture(), TEXT_BACKSLASH ) TODO
+                    // ok to be null ?
+                    .column( "organisationunitid", Long.toString( ouId ) )
+                    .column( "status", "ACTIVE", TEXT_BACKSLASH )
+                    .column( "uid", CodeGenerator.generateUid(), TEXT_BACKSLASH )
+                    .column( "created", created, TEXT_BACKSLASH )
+                    .column( "lastupdated", created, TEXT_BACKSLASH )
+                    .column( "attributeoptioncomboid", Long.toString( defaultaoc ) )
+                    .column( "deleted", "false", TEXT_BACKSLASH )
+                    .column( "eventdatavalues", createDataValuesAsJson(programStage, options.getTeiGenerationOptions().getDataValueRange() ), TEXT_BACKSLASH_NO_ESCAPE  )
+                    .get().toString();
+        } ).collect( Collectors.toList() ) ) );
+
+        // how many program attributes to create //
+        int attributeSize = CollectionSizer.getCollectionSize(options.getTeiGenerationOptions().getEventsRange(), program.getAttributes().size());
+
+        statements.add( Joiner.on( "\n" )
+                .join( IntStream.rangeClosed( 1, attributeSize )
+                        .mapToObj( ev -> {
+
+                            ProgramAttribute attribute = From.from( program.getAttributes() ).get();
+
+                            return sqlInserts().tableName( "trackedentityattributevalue" )
+                                    .column( "trackedentityinstanceid", Long.toString( teiId ) )
+                                    .column( "trackedentityattributeid", Long.toString( attribute.getId() ) )
+                                    .column( "value", rndValueFrom( attribute.getValueType() ), TEXT_BACKSLASH )
+                                    .column( "created", created, TEXT_BACKSLASH )
+                                    .column( "lastupdated", created, TEXT_BACKSLASH ).get().toString();
+                        } )
+                        .collect( Collectors.toList() ) ) );
+
+        return statements;
+    }
+
+    private Program getRandomTrackerProgram( EntityCache entityCache )
+    {
+        return From.from(
+                entityCache.getPrograms().stream().filter( p -> p.getTeiType() != 0 ).collect( Collectors.toList() ) )
+                .get();
+    }
+
+    private String createDataValuesAsJson( ProgramStage programStage, String dataValueSizeRange )
+    {
+        int dataElementsSize = CollectionSizer.getCollectionSize( dataValueSizeRange,
+                programStage.getDataElements().size() );
+
+        // Generate a sequence of int from 0 to max data elements for given program stage
+        List<Integer> indexes = IntStream.range(0, programStage.getDataElements().size() -1).boxed()
+                .collect(Collectors.toCollection(ArrayList::new));
+        // randomize!
+        Collections.shuffle(indexes);
+        // pick only the first x numbers based on randomized user selection
+        indexes = indexes.subList(0, dataElementsSize);
+        List<String> values = new ArrayList<>();
+
+        for (Integer index : indexes)
+        {
+            StringBuilder sb = new StringBuilder();
+
+            DataElement de = programStage.getDataElements().get( index );
+
+            DataValue dv = withRandomValue( de );
+            sb.append( "\"" ).append( de.getUid() ).append( "\":" );
+            try
+            {
+                sb.append( mapper.writeValueAsString( dv ) );
+            }
+            catch ( Exception e )
+            {
+                e.printStackTrace(); // TODO
+            }
+            values.add(sb.toString());
+        }
+        return "{" + Joiner.on(",").join(values) + "}";
+
+    }
+
+    private DataValue withRandomValue( DataElement dataElement)
+    {
+        DataValue dataValue = new DataValue();
+        dataValue.setDataElement( dataElement.getUid() );
+        dataValue.setProvidedElsewhere( false );
+        String val;
+
+        if ( dataElement.getOptionSet() != null && !dataElement.getOptionSet().isEmpty() )
+        {
+            val = dataElement.getOptionSet().get( ints().range( 0, dataElement.getOptionSet().size() - 1 ).get() );
+        }
+        else
+        {
+            val = rndValueFrom( dataElement.getValueType() );
+        }
+        dataValue.setValue( val );
+        return dataValue;
+    }
+
+    private String rndValueFrom(ValueType valueType) {
+        String val = null;
+
+        if ( valueType.isBoolean() )
+        {
+            if ( valueType.equals( ValueType.BOOLEAN ) )
+            {
+                val = String.valueOf( bools().get() );
+            }
+            else
+            {
+                // TRUE_ONLY
+                val = "true";
+            }
+        }
+
+        else if ( valueType.isDate() )
+        {
+            val = localDates().display( DateTimeFormatter.ISO_LOCAL_DATE ).get();
+        }
+
+        else if ( valueType.isNumeric() )
+        {
+            val = String.valueOf( ints().range( 1, 10000 ).get());
+        }
+        else if ( valueType.isDecimal() )
+        {
+            val = String.valueOf( doubles().range( 100.0, 1000.0 ).get() );
+        }
+        else if ( valueType.isText() )
+        {
+            val = Strings.strings().type(StringType.LETTERS).get();
+        }
+        else if ( valueType.isOrganisationUnit() )
+        {
+            val = ""; // TODO
+        }
+        else if ( valueType.isGeo() )
+        {
+            Point p = createRandomPoint();
+            val = p.getY() + ", " + p.getY();
+        }
+        return val;
+    }
+}
Index: src/main/java/org/hisp/dhis/datageneration/generator/GeneratorFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.hisp.dhis.datageneration.generator;\n\n/*\n * Copyright (c) 2004-2019, University of Oslo\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n * Neither the name of the HISP project nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author Luciano Fiandesio\n */\n@Component\npublic class GeneratorFactory\n    implements\n    ApplicationContextAware\n{\n\n    private ApplicationContext context;\n\n    public Generator getGenerator( GeneratorType type )\n    {\n\n        System.out.println(\":\");\n        switch ( type )\n        {\n        case TEI:\n            return context.getBean( \"teiGenerator\", TeiGenerator.class );\n        default:\n            throw new NullPointerException(); // TODO\n\n        }\n\n    }\n\n    @Override\n    public void setApplicationContext( ApplicationContext applicationContext )\n        throws BeansException\n    {\n        this.context = applicationContext;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/org/hisp/dhis/datageneration/generator/GeneratorFactory.java	(date 1568652532000)
+++ src/main/java/org/hisp/dhis/datageneration/generator/GeneratorFactory.java	(date 1568653807193)
@@ -47,15 +47,10 @@
     public Generator getGenerator( GeneratorType type )
     {
 
-        System.out.println(":");
-        switch ( type )
-        {
-        case TEI:
-            return context.getBean( "teiGenerator", TeiGenerator.class );
-        default:
-            throw new NullPointerException(); // TODO
-
+        if (type == GeneratorType.TEI) {
+            return context.getBean("teiGenerator", TeiGenerator.class);
         }
+        throw new IllegalArgumentException();
 
     }
 
Index: src/main/java/org/hisp/dhis/datageneration/observer/ProgressUpdateObserver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.hisp.dhis.datageneration.observer;\n\n/*\n * Copyright (c) 2004-2019, University of Oslo\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n * Neither the name of the HISP project nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport java.util.Observable;\nimport java.util.Observer;\n\nimport org.hisp.dhis.datageneration.shell.ProgressBar;\nimport org.hisp.dhis.datageneration.shell.ShellHelper;\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.StringUtils;\n\n/**\n * @author Luciano Fiandesio\n */\n\n@Component\npublic class ProgressUpdateObserver\n    implements\n    Observer\n{\n\n    private ProgressBar progressBar;\n\n    private ShellHelper shellHelper;\n\n    public ProgressUpdateObserver( ProgressBar progressBar, ShellHelper shellHelper )\n    {\n        this.progressBar = progressBar;\n        this.shellHelper = shellHelper;\n    }\n\n    @Override\n    public void update( Observable observable, Object event )\n    {\n        ProgressUpdateEvent upe = (ProgressUpdateEvent) event;\n        int currentRecord = upe.getCurrentCount().intValue();\n        int totalRecords = upe.getTotalCount().intValue();\n\n        if ( currentRecord == 0 )\n        {\n            // just in case the previous progress bar was interrupted\n            progressBar.reset();\n        }\n\n        String message = null;\n        int percentage = currentRecord * 100 / totalRecords;\n        if ( StringUtils.hasText( upe.getMessage() ) )\n        {\n            message = shellHelper.getWarningMessage( upe.getMessage() );\n            progressBar.display( percentage, message );\n        }\n\n        progressBar.display( percentage, message );\n        if ( percentage == 100 )\n        {\n            progressBar.reset();\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/org/hisp/dhis/datageneration/observer/ProgressUpdateObserver.java	(date 1568652532000)
+++ src/main/java/org/hisp/dhis/datageneration/observer/ProgressUpdateObserver.java	(date 1568653633318)
@@ -34,7 +34,6 @@
 import org.hisp.dhis.datageneration.shell.ProgressBar;
 import org.hisp.dhis.datageneration.shell.ShellHelper;
 import org.springframework.stereotype.Component;
-import org.springframework.stereotype.Service;
 import org.springframework.util.StringUtils;
 
 /**
Index: src/main/java/org/hisp/dhis/datageneration/generator/TeiGenerationOptions.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.hisp.dhis.datageneration.generator;\n\n/*\n * Copyright (c) 2004-2019, University of Oslo\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n * Neither the name of the HISP project nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport lombok.Builder;\nimport lombok.Getter;\n\n/**\n * @author Luciano Fiandesio\n */\n@Builder\n@Getter\npublic class TeiGenerationOptions\n{\n\n    private String eventsRange;\n\n    private String attributeRange;\n\n    private String dataValueRange;\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/org/hisp/dhis/datageneration/generator/TeiGenerationOptions.java	(date 1568652532000)
+++ src/main/java/org/hisp/dhis/datageneration/generator/TeiGenerationOptions.java	(date 1568653619258)
@@ -38,11 +38,25 @@
 @Getter
 public class TeiGenerationOptions
 {
-
+    /**
+     * Range of numbers of events to generate for each Tei example: 1-10 -> for each
+     * Tei, a number of Events between one and ten will be generated
+     * 
+     */
     private String eventsRange;
 
+    /**
+     * Range of numbers of Attributes generated for each Tei example: 1-10 If the
+     * TEI has less then the highest number in the range, the highest number will
+     * become the max number of Attributes
+     */
     private String attributeRange;
 
+    /**
+     * Range of numbers of Data Elements generated for each Tei example: 1-10 If the
+     * TEI has less then the highest number in the range, the highest number will
+     * become the max number of Data Elements
+     */
     private String dataValueRange;
 
 }
Index: src/main/java/org/hisp/dhis/datageneration/config/DataSourceConfig.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.hisp.dhis.datageneration.config;\n\n/*\n * Copyright (c) 2004-2019, University of Oslo\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n * Neither the name of the HISP project nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport javax.sql.DataSource;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.jdbc.DataSourceBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.DependsOn;\n\n/**\n * @author Luciano Fiandesio\n */\n@Configuration\npublic class DataSourceConfig\n{\n\n    @Value( \"${connection.username}\" )\n    private String userName;\n\n    @Value( \"${connection.password}\" )\n    private String password;\n\n    @Value( \"${connection.url}\" )\n    private String url;\n\n    @Value( \"${connection.driver_class}\" )\n    private String driver;\n\n    @DependsOn( \"propertySourcesPlaceholderConfigurer\" )\n    @Bean( name = \"dataSource\" )\n    public DataSource dataSource()\n    {\n\n        return DataSourceBuilder.create().driverClassName( driver ).username( userName ).password( password ).url( url )\n            .build();\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/org/hisp/dhis/datageneration/config/DataSourceConfig.java	(date 1568652532000)
+++ src/main/java/org/hisp/dhis/datageneration/config/DataSourceConfig.java	(date 1568653807185)
@@ -59,7 +59,6 @@
     @Bean( name = "dataSource" )
     public DataSource dataSource()
     {
-
         return DataSourceBuilder.create().driverClassName( driver ).username( userName ).password( password ).url( url )
             .build();
     }
